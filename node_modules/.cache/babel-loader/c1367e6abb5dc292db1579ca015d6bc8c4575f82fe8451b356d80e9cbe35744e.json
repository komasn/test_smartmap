{"ast":null,"code":"import _createForOfIteratorHelper from\"/home/magari/git/test_smartmap/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";import _regeneratorRuntime from\"/home/magari/git/test_smartmap/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";import _asyncToGenerator from\"/home/magari/git/test_smartmap/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";import _createClass from\"/home/magari/git/test_smartmap/node_modules/@babel/runtime/helpers/esm/createClass.js\";import _classCallCheck from\"/home/magari/git/test_smartmap/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";import _inherits from\"/home/magari/git/test_smartmap/node_modules/@babel/runtime/helpers/esm/inherits.js\";import _createSuper from\"/home/magari/git/test_smartmap/node_modules/@babel/runtime/helpers/esm/createSuper.js\";import _wrapNativeSuper from\"/home/magari/git/test_smartmap/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js\";var sleep=function sleep(ms){return new Promise(function(resolve){return window.setTimeout(resolve,ms);});};var WS_PING_INTERVAL=30000;// 30 seconds\nvar WS_URL=\"wss://api-ws.geolonia.com/\".concat(process.env.REACT_APP_API_STAGE||'dev');export var WebSocketMessageEvent=/*#__PURE__*/function(_CustomEvent){_inherits(WebSocketMessageEvent,_CustomEvent);var _super=_createSuper(WebSocketMessageEvent);function WebSocketMessageEvent(){_classCallCheck(this,WebSocketMessageEvent);return _super.apply(this,arguments);}return _createClass(WebSocketMessageEvent);}(/*#__PURE__*/_wrapNativeSuper(CustomEvent));var WebSocketController=/*#__PURE__*/function(){function WebSocketController(){_classCallCheck(this,WebSocketController);this.ws=void 0;this.subscriptions=void 0;this.ws=this._startWebSocket();this.subscriptions={};window.setTimeout(this._sendPing.bind(this),WS_PING_INTERVAL);}_createClass(WebSocketController,[{key:\"subscribe\",value:function subscribe(channel,messageCallback){var _this$subscriptions;var callbacksForThisChannel=(_this$subscriptions=this.subscriptions)[channel]||(_this$subscriptions[channel]=new Set());callbacksForThisChannel.add(messageCallback);// Send the subscribe message only if we are open.\n// We don't need to do this if we aren't open, because\n// we have an event handler listening for the open event\nif(this.ws.readyState===WebSocket.OPEN){this.ws.send(JSON.stringify({action:\"subscribe\",channel:channel}));}}},{key:\"unsubscribe\",value:function unsubscribe(channel,messageCallback){var _this$subscriptions2;var callbacksForThisChannel=(_this$subscriptions2=this.subscriptions)[channel]||(_this$subscriptions2[channel]=new Set());callbacksForThisChannel.delete(messageCallback);}},{key:\"_startWebSocket\",value:function _startWebSocket(){var _this=this;var ws=new WebSocket(WS_URL);ws.addEventListener('open',function(){// re-subscribe to any channels that we were previously connected to\nfor(var _i=0,_Object$keys=Object.keys(_this.subscriptions);_i<_Object$keys.length;_i++){var channel=_Object$keys[_i];ws.send(JSON.stringify({action:\"subscribe\",channel:channel}));}});ws.addEventListener('close',/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(){return _regeneratorRuntime().wrap(function _callee$(_context){while(1)switch(_context.prev=_context.next){case 0:_context.next=2;return sleep(300);case 2:_this.ws=_this._startWebSocket();case 3:case\"end\":return _context.stop();}},_callee);})));ws.addEventListener('message',function(message){var data=JSON.parse(message.data);if(data.msg==='pong'&&data.now){// this._filterFeaturesByTTL(data.now);\n}else if(data.msg==='subscribed'){// no-op, this is just a message verifying that we've been subscribed\n}else if(typeof data.id!=='undefined'){var channel=data.chan;var callbacksForThisChannel=_this.subscriptions[channel]||new Set();var _iterator=_createForOfIteratorHelper(callbacksForThisChannel),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var callback=_step.value;callback(data);}}catch(err){_iterator.e(err);}finally{_iterator.f();}}else{console.warn('Unrecognized WS message: ',message.data);}});return ws;}},{key:\"_sendPing\",value:function _sendPing(){if(this.ws.readyState===WebSocket.OPEN){this.ws.send(JSON.stringify({\"action\":\"ping\"}));}window.setTimeout(this._sendPing.bind(this),WS_PING_INTERVAL);}}]);return WebSocketController;}();var controller=new WebSocketController();export default controller;","map":{"version":3,"names":["sleep","ms","Promise","resolve","window","setTimeout","WS_PING_INTERVAL","WS_URL","concat","process","env","REACT_APP_API_STAGE","WebSocketMessageEvent","_CustomEvent","_inherits","_super","_createSuper","_classCallCheck","apply","arguments","_createClass","_wrapNativeSuper","CustomEvent","WebSocketController","ws","subscriptions","_startWebSocket","_sendPing","bind","key","value","subscribe","channel","messageCallback","_this$subscriptions","callbacksForThisChannel","Set","add","readyState","WebSocket","OPEN","send","JSON","stringify","action","unsubscribe","_this$subscriptions2","delete","_this","addEventListener","_i","_Object$keys","Object","keys","length","_asyncToGenerator","_regeneratorRuntime","mark","_callee","wrap","_callee$","_context","prev","next","stop","message","data","parse","msg","now","id","chan","_iterator","_createForOfIteratorHelper","_step","s","n","done","callback","err","e","f","console","warn","controller"],"sources":["/home/magari/git/test_smartmap/src/cityos/lib/websocket.ts"],"sourcesContent":["const sleep = (ms: number) => new Promise((resolve) => window.setTimeout(resolve, ms));\n\nconst WS_PING_INTERVAL = 30_000; // 30 seconds\nconst WS_URL = `wss://api-ws.geolonia.com/${process.env.REACT_APP_API_STAGE || 'dev'}`;\n\ntype WebSocketMessageEventDetail = {\n  message: any\n}\nexport class WebSocketMessageEvent extends CustomEvent<WebSocketMessageEventDetail> {}\n\nexport type MessageCallbackFunc = (message: any) => void\n\nclass WebSocketController {\n  ws: WebSocket\n  subscriptions: { [key: string]: Set<MessageCallbackFunc> }\n\n  constructor() {\n    this.ws = this._startWebSocket();\n    this.subscriptions = {};\n    window.setTimeout(this._sendPing.bind(this), WS_PING_INTERVAL);\n  }\n\n  subscribe(channel: string, messageCallback: MessageCallbackFunc) {\n    const callbacksForThisChannel = this.subscriptions[channel] ||= new Set();\n    callbacksForThisChannel.add(messageCallback);\n\n    // Send the subscribe message only if we are open.\n    // We don't need to do this if we aren't open, because\n    // we have an event handler listening for the open event\n    if (this.ws.readyState === WebSocket.OPEN) {\n      this.ws.send(JSON.stringify({\n        action: \"subscribe\",\n        channel,\n      }));\n    }\n  }\n\n  unsubscribe(channel: string, messageCallback: MessageCallbackFunc) {\n    const callbacksForThisChannel = this.subscriptions[channel] ||= new Set();\n    callbacksForThisChannel.delete(messageCallback);\n  }\n\n  private _startWebSocket() {\n    const ws = new WebSocket(WS_URL);\n    ws.addEventListener('open', () => {\n      // re-subscribe to any channels that we were previously connected to\n      for (const channel of Object.keys(this.subscriptions)) {\n        ws.send(JSON.stringify({\n          action: \"subscribe\",\n          channel,\n        }));\n      }\n    });\n    ws.addEventListener('close', async () => {\n      await sleep(300);\n      this.ws = this._startWebSocket();\n    });\n    ws.addEventListener('message', (message: MessageEvent<string>) => {\n      const data = JSON.parse(message.data);\n      if (data.msg === 'pong' && data.now) {\n        // this._filterFeaturesByTTL(data.now);\n      } else if (data.msg === 'subscribed') {\n        // no-op, this is just a message verifying that we've been subscribed\n      } else if (typeof data.id !== 'undefined') {\n        const channel = data.chan;\n        const callbacksForThisChannel = this.subscriptions[channel] || new Set();\n        for (const callback of callbacksForThisChannel) {\n          callback(data);\n        }\n      } else {\n        console.warn('Unrecognized WS message: ', message.data);\n      }\n    });\n    return ws;\n  }\n\n  private _sendPing() {\n    if (this.ws.readyState === WebSocket.OPEN) {\n      this.ws.send(JSON.stringify({\"action\": \"ping\"}));\n    }\n    window.setTimeout(this._sendPing.bind(this), WS_PING_INTERVAL);\n  }\n}\n\nconst controller = new WebSocketController();\nexport default controller;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}