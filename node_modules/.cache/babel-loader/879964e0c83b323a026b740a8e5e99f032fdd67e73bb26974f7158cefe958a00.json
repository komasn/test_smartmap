{"ast":null,"code":"const sleep = ms => new Promise(resolve => window.setTimeout(resolve, ms));\nconst WS_PING_INTERVAL = 30000; // 30 seconds\nconst WS_URL = `wss://api-ws.geolonia.com/${process.env.REACT_APP_API_STAGE || 'dev'}`;\nexport class WebSocketMessageEvent extends CustomEvent {}\nclass WebSocketController {\n  constructor() {\n    this.ws = void 0;\n    this.subscriptions = void 0;\n    this.ws = this._startWebSocket();\n    this.subscriptions = {};\n    window.setTimeout(this._sendPing.bind(this), WS_PING_INTERVAL);\n  }\n  subscribe(channel, messageCallback) {\n    const callbacksForThisChannel = this.subscriptions[channel] ||= new Set();\n    callbacksForThisChannel.add(messageCallback);\n\n    // Send the subscribe message only if we are open.\n    // We don't need to do this if we aren't open, because\n    // we have an event handler listening for the open event\n    if (this.ws.readyState === WebSocket.OPEN) {\n      this.ws.send(JSON.stringify({\n        action: \"subscribe\",\n        channel\n      }));\n    }\n  }\n  unsubscribe(channel, messageCallback) {\n    const callbacksForThisChannel = this.subscriptions[channel] ||= new Set();\n    callbacksForThisChannel.delete(messageCallback);\n  }\n  _startWebSocket() {\n    const ws = new WebSocket(WS_URL);\n    ws.addEventListener('open', () => {\n      // re-subscribe to any channels that we were previously connected to\n      for (const channel of Object.keys(this.subscriptions)) {\n        ws.send(JSON.stringify({\n          action: \"subscribe\",\n          channel\n        }));\n      }\n    });\n    ws.addEventListener('close', async () => {\n      await sleep(300);\n      this.ws = this._startWebSocket();\n    });\n    ws.addEventListener('message', message => {\n      const data = JSON.parse(message.data);\n      if (data.msg === 'pong' && data.now) {\n        // this._filterFeaturesByTTL(data.now);\n      } else if (data.msg === 'subscribed') {\n        // no-op, this is just a message verifying that we've been subscribed\n      } else if (typeof data.id !== 'undefined') {\n        const channel = data.chan;\n        const callbacksForThisChannel = this.subscriptions[channel] || new Set();\n        for (const callback of callbacksForThisChannel) {\n          callback(data);\n        }\n      } else {\n        console.warn('Unrecognized WS message: ', message.data);\n      }\n    });\n    return ws;\n  }\n  _sendPing() {\n    if (this.ws.readyState === WebSocket.OPEN) {\n      this.ws.send(JSON.stringify({\n        \"action\": \"ping\"\n      }));\n    }\n    window.setTimeout(this._sendPing.bind(this), WS_PING_INTERVAL);\n  }\n}\nconst controller = new WebSocketController();\nexport default controller;","map":{"version":3,"names":["sleep","ms","Promise","resolve","window","setTimeout","WS_PING_INTERVAL","WS_URL","process","env","REACT_APP_API_STAGE","WebSocketMessageEvent","CustomEvent","WebSocketController","constructor","ws","subscriptions","_startWebSocket","_sendPing","bind","subscribe","channel","messageCallback","callbacksForThisChannel","Set","add","readyState","WebSocket","OPEN","send","JSON","stringify","action","unsubscribe","delete","addEventListener","Object","keys","message","data","parse","msg","now","id","chan","callback","console","warn","controller"],"sources":["/home/magari/git/test_smartmap/src/cityos/lib/websocket.ts"],"sourcesContent":["const sleep = (ms: number) => new Promise((resolve) => window.setTimeout(resolve, ms));\n\nconst WS_PING_INTERVAL = 30_000; // 30 seconds\nconst WS_URL = `wss://api-ws.geolonia.com/${process.env.REACT_APP_API_STAGE || 'dev'}`;\n\ntype WebSocketMessageEventDetail = {\n  message: any\n}\nexport class WebSocketMessageEvent extends CustomEvent<WebSocketMessageEventDetail> {}\n\nexport type MessageCallbackFunc = (message: any) => void\n\nclass WebSocketController {\n  ws: WebSocket\n  subscriptions: { [key: string]: Set<MessageCallbackFunc> }\n\n  constructor() {\n    this.ws = this._startWebSocket();\n    this.subscriptions = {};\n    window.setTimeout(this._sendPing.bind(this), WS_PING_INTERVAL);\n  }\n\n  subscribe(channel: string, messageCallback: MessageCallbackFunc) {\n    const callbacksForThisChannel = this.subscriptions[channel] ||= new Set();\n    callbacksForThisChannel.add(messageCallback);\n\n    // Send the subscribe message only if we are open.\n    // We don't need to do this if we aren't open, because\n    // we have an event handler listening for the open event\n    if (this.ws.readyState === WebSocket.OPEN) {\n      this.ws.send(JSON.stringify({\n        action: \"subscribe\",\n        channel,\n      }));\n    }\n  }\n\n  unsubscribe(channel: string, messageCallback: MessageCallbackFunc) {\n    const callbacksForThisChannel = this.subscriptions[channel] ||= new Set();\n    callbacksForThisChannel.delete(messageCallback);\n  }\n\n  private _startWebSocket() {\n    const ws = new WebSocket(WS_URL);\n    ws.addEventListener('open', () => {\n      // re-subscribe to any channels that we were previously connected to\n      for (const channel of Object.keys(this.subscriptions)) {\n        ws.send(JSON.stringify({\n          action: \"subscribe\",\n          channel,\n        }));\n      }\n    });\n    ws.addEventListener('close', async () => {\n      await sleep(300);\n      this.ws = this._startWebSocket();\n    });\n    ws.addEventListener('message', (message: MessageEvent<string>) => {\n      const data = JSON.parse(message.data);\n      if (data.msg === 'pong' && data.now) {\n        // this._filterFeaturesByTTL(data.now);\n      } else if (data.msg === 'subscribed') {\n        // no-op, this is just a message verifying that we've been subscribed\n      } else if (typeof data.id !== 'undefined') {\n        const channel = data.chan;\n        const callbacksForThisChannel = this.subscriptions[channel] || new Set();\n        for (const callback of callbacksForThisChannel) {\n          callback(data);\n        }\n      } else {\n        console.warn('Unrecognized WS message: ', message.data);\n      }\n    });\n    return ws;\n  }\n\n  private _sendPing() {\n    if (this.ws.readyState === WebSocket.OPEN) {\n      this.ws.send(JSON.stringify({\"action\": \"ping\"}));\n    }\n    window.setTimeout(this._sendPing.bind(this), WS_PING_INTERVAL);\n  }\n}\n\nconst controller = new WebSocketController();\nexport default controller;\n"],"mappings":"AAAA,MAAMA,KAAK,GAAIC,EAAU,IAAK,IAAIC,OAAO,CAAEC,OAAO,IAAKC,MAAM,CAACC,UAAU,CAACF,OAAO,EAAEF,EAAE,CAAC,CAAC;AAEtF,MAAMK,gBAAgB,GAAG,KAAM,CAAC,CAAC;AACjC,MAAMC,MAAM,GAAI,6BAA4BC,OAAO,CAACC,GAAG,CAACC,mBAAmB,IAAI,KAAM,EAAC;AAKtF,OAAO,MAAMC,qBAAqB,SAASC,WAAW,CAA8B;AAIpF,MAAMC,mBAAmB,CAAC;EAIxBC,WAAWA,CAAA,EAAG;IAAA,KAHdC,EAAE;IAAA,KACFC,aAAa;IAGX,IAAI,CAACD,EAAE,GAAG,IAAI,CAACE,eAAe,CAAC,CAAC;IAChC,IAAI,CAACD,aAAa,GAAG,CAAC,CAAC;IACvBZ,MAAM,CAACC,UAAU,CAAC,IAAI,CAACa,SAAS,CAACC,IAAI,CAAC,IAAI,CAAC,EAAEb,gBAAgB,CAAC;EAChE;EAEAc,SAASA,CAACC,OAAe,EAAEC,eAAoC,EAAE;IAC/D,MAAMC,uBAAuB,GAAG,IAAI,CAACP,aAAa,CAACK,OAAO,CAAC,KAAK,IAAIG,GAAG,CAAC,CAAC;IACzED,uBAAuB,CAACE,GAAG,CAACH,eAAe,CAAC;;IAE5C;IACA;IACA;IACA,IAAI,IAAI,CAACP,EAAE,CAACW,UAAU,KAAKC,SAAS,CAACC,IAAI,EAAE;MACzC,IAAI,CAACb,EAAE,CAACc,IAAI,CAACC,IAAI,CAACC,SAAS,CAAC;QAC1BC,MAAM,EAAE,WAAW;QACnBX;MACF,CAAC,CAAC,CAAC;IACL;EACF;EAEAY,WAAWA,CAACZ,OAAe,EAAEC,eAAoC,EAAE;IACjE,MAAMC,uBAAuB,GAAG,IAAI,CAACP,aAAa,CAACK,OAAO,CAAC,KAAK,IAAIG,GAAG,CAAC,CAAC;IACzED,uBAAuB,CAACW,MAAM,CAACZ,eAAe,CAAC;EACjD;EAEQL,eAAeA,CAAA,EAAG;IACxB,MAAMF,EAAE,GAAG,IAAIY,SAAS,CAACpB,MAAM,CAAC;IAChCQ,EAAE,CAACoB,gBAAgB,CAAC,MAAM,EAAE,MAAM;MAChC;MACA,KAAK,MAAMd,OAAO,IAAIe,MAAM,CAACC,IAAI,CAAC,IAAI,CAACrB,aAAa,CAAC,EAAE;QACrDD,EAAE,CAACc,IAAI,CAACC,IAAI,CAACC,SAAS,CAAC;UACrBC,MAAM,EAAE,WAAW;UACnBX;QACF,CAAC,CAAC,CAAC;MACL;IACF,CAAC,CAAC;IACFN,EAAE,CAACoB,gBAAgB,CAAC,OAAO,EAAE,YAAY;MACvC,MAAMnC,KAAK,CAAC,GAAG,CAAC;MAChB,IAAI,CAACe,EAAE,GAAG,IAAI,CAACE,eAAe,CAAC,CAAC;IAClC,CAAC,CAAC;IACFF,EAAE,CAACoB,gBAAgB,CAAC,SAAS,EAAGG,OAA6B,IAAK;MAChE,MAAMC,IAAI,GAAGT,IAAI,CAACU,KAAK,CAACF,OAAO,CAACC,IAAI,CAAC;MACrC,IAAIA,IAAI,CAACE,GAAG,KAAK,MAAM,IAAIF,IAAI,CAACG,GAAG,EAAE;QACnC;MAAA,CACD,MAAM,IAAIH,IAAI,CAACE,GAAG,KAAK,YAAY,EAAE;QACpC;MAAA,CACD,MAAM,IAAI,OAAOF,IAAI,CAACI,EAAE,KAAK,WAAW,EAAE;QACzC,MAAMtB,OAAO,GAAGkB,IAAI,CAACK,IAAI;QACzB,MAAMrB,uBAAuB,GAAG,IAAI,CAACP,aAAa,CAACK,OAAO,CAAC,IAAI,IAAIG,GAAG,CAAC,CAAC;QACxE,KAAK,MAAMqB,QAAQ,IAAItB,uBAAuB,EAAE;UAC9CsB,QAAQ,CAACN,IAAI,CAAC;QAChB;MACF,CAAC,MAAM;QACLO,OAAO,CAACC,IAAI,CAAC,2BAA2B,EAAET,OAAO,CAACC,IAAI,CAAC;MACzD;IACF,CAAC,CAAC;IACF,OAAOxB,EAAE;EACX;EAEQG,SAASA,CAAA,EAAG;IAClB,IAAI,IAAI,CAACH,EAAE,CAACW,UAAU,KAAKC,SAAS,CAACC,IAAI,EAAE;MACzC,IAAI,CAACb,EAAE,CAACc,IAAI,CAACC,IAAI,CAACC,SAAS,CAAC;QAAC,QAAQ,EAAE;MAAM,CAAC,CAAC,CAAC;IAClD;IACA3B,MAAM,CAACC,UAAU,CAAC,IAAI,CAACa,SAAS,CAACC,IAAI,CAAC,IAAI,CAAC,EAAEb,gBAAgB,CAAC;EAChE;AACF;AAEA,MAAM0C,UAAU,GAAG,IAAInC,mBAAmB,CAAC,CAAC;AAC5C,eAAemC,UAAU"},"metadata":{},"sourceType":"module","externalDependencies":[]}